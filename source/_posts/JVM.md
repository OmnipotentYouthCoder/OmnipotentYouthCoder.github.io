---
title: JVM
date: 2022-06-13 19:06:11
tags: JAVA
categories: 编程
---

# JVM入门【持续补充】

## jvm的位置

{% asset_img image-1.png %}



## jvm的体系结构

- 源文件由编译器编译成字节码（ByteCode） 
- 字节码由java虚拟机解释运行。因为java程序既要编译同时也要经过JVM的解释运行

{% asset_img image-2.png %}

1. 类加载器（Class Loader）子系统

2. 执行引擎（Execution Engine）

3. 运行时数据区(Runtime Data Area)

   - 线程私有数据区（不会有垃圾回收）

     1. Java栈 VM Stack

        - 是Java方法执行的内存模型。

        - **Java栈中存放的是一个个的栈帧，** 每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息。
        - 当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。
        - 会有两种异常StackOverFlowError和 OutOfMemoryError。当线程请求栈深度大于虚拟机所允许的深度就会抛出StackOverFlowError错误；虚拟机栈动态扩展，当扩展无法申请到足够的内存空间时候，抛出OutOfMemoryError。它是线程私有的，生命周期与线程相同。

     2. 本地方法栈 Native Method

        - Java栈是为执行Java方法服务的， 而本地方法栈则是为执行本地方法（Native Method）服务的。
        - 与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常
        - 在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。

     3. 程序计数器 Program Counter Register

        - 程序计数器是一块较小的内存空间， **可以看作是当前线程所执行的字节码的行号指示器。** 分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
        - 由于Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，**每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储**，我们称这类内存区域为 **“线程私有”** 的内存。
        - 如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。
        - 程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)

   - 线程共享数据区（需要垃圾回收：堆）

     1. 方法区Method Area
        - 用于存储类信息（构造方法、接口定义）、常量池、静态变量、JIT编译后的代码等数据，（永久代是HotSpot虚拟机特有的概念，是对方法区的实现，别的JVM没有永久代的概念） 
        - 被所有线程共享
     2. 堆 heap



## 类加载器

- 作用：加载class文件

 {% asset_img image-3.png %}

 {% asset_img image-4.png %}
- 分类（对象.getClass().getClassLoader()）
  1. 虚拟机自带的加载器
  2. 启动类（根）加载器（/jre/lib/rt.jar）
  3. 扩展类加载器（/jre/lib/ext）
  4. 应用程序加载器



## 双亲委派机制

1. 类加载器收到类加载的请求
2. 将请求向上委托给父类加载器中，一直向上委托，能加载就结束并使用当前加载器。APP类加载器 --> ext加载器 --> BOOT（最终执行）
3. 不能加载则抛出异常（Class not found），通知子加载器进行加载



## 沙箱安全机制

1. Java安全模型的核心就是Java沙箱（sandbox），什么是沙箱？沙箱是一个限制程序运行的环境。沙箱机制就是将 Java 代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。沙箱**主要限制系统资源访问**，那系统资源包括什么？——CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。

2. 安全模型

   当前最新的安全机制实现，则引入了域 (Domain) 的概念。虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域 (Protected Domain)，对应不一样的权限 (Permission)。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示 最新的安全模型(jdk 1.6)
   ![在这里插入图片描述](https://img-blog.csdn.net/20181022103108566?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwMzM2NDMz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

3. doPrivileged 方法能够使一段受信任代码获得更大的权限，甚至比调用它的应用程序还要多，可做到临时访问更多的资源。有时候这是非常必要的，可以应付一些特殊的应用场景。例如，应用程序可能无法直接访问某些系统资源，但这样的应用程序必须得到这些资源才能够完成功能。

4. 基本组件：

   - 字节码校验器（bytecode verifier）：确保Java类文件遵循Java语言规范。这样可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。

   - 类装载器

     （class loader）：其中类装载器在3个方面对Java沙箱起作用

     - 它防止恶意代码去干涉善意的代码；
     - 它守护了被信任的类库边界；
     - 它将代码归入保护域，确定了代码可以进行哪些操作。

     虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类将有一个名字，这个命名空间是由Java虚拟机为每一个类装载器维护的，它们互相之间甚至不可见。

   - 存取控制器（access controller）：存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定，可以由用户指定。
   - 安全管理器（security manager）：是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。
   - 安全软件包（security package）：java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括：
     - 安全提供者
     - 消息摘要
     - 数字签名
     - 加密
     - 鉴别

5. 要素：

   1. 权限
   2. 代码源
   3. 保护欲
   4. 策略文件
   5. 密钥库



## native关键字

- 超出java的作用范围，去调底层c库

- 会进入本地方法栈，调用本地方法接口（JNI），扩展java的使用
- 本地方法栈，登记本地native方法
- 最终执行时通过JNI加载本地方法库



## 栈帧

 {% asset_img image-6.png %}



## 堆

- 一个JVM只有一个堆内存，大小可以调节

- 保存类、方法、常量、变量、引用类型的真实对象

- 分区

  - 新生区

    - 类的初始至结束
    - 伊甸园区（Eden） -->满了触发轻GC
    - 幸存者0区
    - 幸存者1区

  - 养老区（Old）

  - 永久区（Perm）【逻辑上存在，物理上不存在，有人称为非堆】

    - 常驻内存，用来存放JDK自身携带的对象，interface元数据，存储的是JAVA运行时的环境和类信息
    - 不存在垃圾回收
    - 关闭虚拟机会释放内存

    - jdk6之前，永久代，常量池在方法区
    - jdk7，永久代，常量池在堆中
    - jdk8之后，无永久代，称为元空间，常量池在元空间



## GC垃圾回收

- 轻量级GC 新生区

  伊甸园区满了会触发轻GC，有的对象仍存在引用，存到幸存者区。幸存者区满了进养老区

- 重量级GC 新生区和养老区

  新生区满了触发重GC（据调查，99%的对象是临时对象）



## OOM问题（OutOfMemoryError）

1. 尝试扩大堆内存

   -Xms1024m -Xmx1024m -XX:+PrintGCDetails

2. JProfile分析内存，内存快照分析工具

   1. 分析Dump内存文件，快速定位内存泄露
   
      -Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemory
   
      // -Xms 设置初始化内存分配大小
   
      // -Xmx 设置最大分配内存
   
 {% asset_img image-6.png %}
   
 {% asset_img image-7.png %}
   
   2. 获得堆中的数据
   
   3. 获得大的对象



## GC引用计数法

 {% asset_img image-8.png %}




## GC复制算法

- 主要用于年轻代
- 好处：没有内存的碎片
- 坏处：浪费了内存空间，有一半空间是空的（to区）
- 最佳使用场景：对象存活度较低

 {% asset_img image-9.png %}

 {% asset_img image-10.png %}



## GC标记压缩清除算法

- 描述

  1. 扫描对象，对活着的对象进行标记

  2. 对没有标记的对象进行清除

 {% asset_img image-11.png %}

- 优点：不需要额外的空间

- 缺点：两次扫描，严重浪费时间，产生内存碎片

- 再优化：压缩：防止内存碎片

  - 再次扫描，多了移动成本

  - 多次清除后再压缩节约成本

 {% asset_img image-12.png %}

## GC算法总结

- 内存效率：复制算法 > 标记清除算法 > 标记压缩算法（时间复杂度）
- 内存整齐度：复制算法 = 标记压缩算法 > 标记清除算法
- 内存利用率：标记压缩算法 = 标记清除算法 > 复制算法



## 分代收集算法

年轻代：存活率低，复制算法

老年代：区域大，存活率高，标记清除和标记压缩混合实现



## JMM

1. 描述：

   - java内存模型 ，java memory model。 

     {% asset_img image-13.png %}

   - 定义了线程工作内存和主内存的抽象关系，线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory）

 {% asset_img image-14.png %}
 
   - 缓存一致性协议，用于定义数据读写的规则

2. volilate 解决对象可见性

   - 表示这个变量在不同线程中是共享，编译器与运行时都会注意到这个变量是**共享**的，因此不会对该变量进行**重排序**。
   - volatile关键字保证可见性、有序性。但不保证原子性。

3. **JMM的八种交互操作**（每个操作都为[原子操作](https://so.csdn.net/so/search?q=原子操作&spm=1001.2101.3001.7020)）

   - lock （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态
   - unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
   - read （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
   - load （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中
   - use （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令
   - assign （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中
   - store （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用
   - write 　（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中

4. 八种操作的规则

   - 不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write
   - 不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存
   - 不允许一个线程将没有assign的数据从工作内存同步回主内存
   - 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过assign和load操作
   - 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁
   - 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值
   - 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量
   - 对一个变量进行unlock操作之前，必须把此变量同步回主内存