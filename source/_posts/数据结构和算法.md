---
title: 数据结构和算法
date: 2022-07-22 19:26:07
tags: JAVA
categories: 编程
---

# 数据结构和算法

## 1. 时间复杂度

- 常数操作：一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。
- 时间复杂度：一个算法流程中，常数操作数量的一个指标，O
- 表达式中只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果为f(N)，name时间复杂度为O(f(N))。
- 常数项时间：评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，叫做常数项时间
- O(1)常数阶 < O(logn)对数阶 < O(n)线性阶 < O(n^2)平方阶 < O(n^3)(立方阶) < O(2^n) (指数阶)

{% asset_img image-1.png %}

## 2. 对数器

1. 有一个你想要测的方法a 
2. 实现复杂度不好但是容易实现的方法b 
3. 实现一个随机样本产生器 
4. 把方法a和方法b跑相同的随机样本，看看得到的结果是否一样。 
5. 如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a或者方法b 
6. 当样本数量很多时比对测试依然正确，可以确定方法a已经正确



## 3. 比较器

实现Comparator接口，重写compare方法，实现复杂的比价策略



## 4. 递归

1. master公式

    ```
    T(N) = a*T(N/b) + O(N^d)
    // N:母规模,a:次数,b:子规模
    ```
    
    - log(b,a) > d -> 复杂度为O(N^log(b,a))
    
    - log(b,a) = d -> 复杂度为O(N^d * logN)
    
    -  log(b,a) < d -> 复杂度为O(N^d)



## 5. 树

### 1. 描述

- 特点

  - 一棵树中的任意两个结点有且仅有唯一的一条路径连通。

  - 一棵树如果有 n 个结点，那么它一定恰好有 n-1 条边。

  - 一棵树不包含回路。

- 概念

  - **节点** ：树中的每个元素都可以统称为节点。
  - **根节点** ：顶层节点或者说没有父节点的节点。
  - **父节点** ：若一个节点含有子节点，则这个节点称为其子节点的父节点。
  - **子节点** ：一个节点含有的子树的根节点称为该节点的子节点。
  - **兄弟节点** ：具有相同父节点的节点互称为兄弟节点。
  - **叶子节点** ：没有子节点的节点。
  - **节点的高度** ：该节点到叶子节点的最长路径所包含的边数。
  - **节点的深度** ：根节点到该节点的路径所包含的边数
  - **节点的层数** ：节点的深度+1。
  - **树的高度** ：根节点的高度。

- 二叉树

  **二叉树**（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。

  **二叉树** 的分支通常被称作“**左子树**”或“**右子树**”。并且，**二叉树** 的分支具有左右次序，不能随意颠倒。

  **二叉树** 的第 i 层至多拥有 `2^(i-1)` 个节点，深度为 k 的二叉树至多总共有 `2^(k+1)-1` 个节点（满二叉树的情况），至少有 2^(k) 个节点

  ```java
  class Node<V>{
      V value;
      Node left;
      Node right;
  }
  ```

- 满二叉树

  一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是 **满二叉树**。也就是说，如果一个二叉树的层数为 K，且结点总数是(2^k) -1 ，则它就是 **满二叉树**。满二叉树一定是完全二叉树。

  - 判断方法：求深度k，求节点个数，满足(2^k) -1

- 完全二叉树

  除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则这个二叉树就是 **完全二叉树** 。

  **父结点和子节点的序号有着对应关系。**

  - 判断方法1：层级遍历，如果出现有右子节点无左子节点的情况，返回false；当遇到第一个左右子节点不全的节点，剩余节点必须是叶子结点，否则false

- 平衡二叉树
  1. 可以是一棵空树
  2. 如果不是空树，它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。
  
- 搜索二叉树

  每个节点的左子节点都比它小，右子节点都比它大。经典搜索二叉树一般认为没有重复值。

  中序遍历可以得出升序的排序

  - 判断方法1：中序遍历后看排序是否升序
  - 判断方法2：递归每一个子树是否满足搜索二叉树



### 2. 存储

1. 链式存储

   二叉树的链式存储依靠指针将各个节点串联起来，不需要连续的存储空间。引用对象。

2. 顺序存储

   利用数组进行存储，数组中的每一个位置仅存储节点的 data，不存储左右子节点的指针，子节点的索引通过数组下标完成。根结点的序号为 1，对于每个节点 Node，假设它存储在数组中下标为 i 的位置，那么它的左子节点就存储在 2i 的位置，它的右子节点存储在下标为 2i+1 的位置。



### 3. 遍历

- 先序遍历

  二叉树的先序遍历，就是先输出根结点，再遍历左子树，最后遍历右子树，遍历左子树和右子树的时候，同样遵循先序遍历的规则，也就是说，我们可以递归实现先序遍历。

  ```java
  public void preOrder(TreeNode root){
  	if(root == null){
  		return;
  	}
  	system.out.println(root.data);
  	preOrder(root.left);
  	preOrder(root.right);
  }
  ```

- 中序遍历

  二叉树的中序遍历，就是先递归中序遍历左子树，再输出根结点的值，再递归中序遍历右子树。

  ```java
  public void inOrder(TreeNode root){
  	if(root == null){
  		return;
  	}
  	inOrder(root.left);
  	system.out.println(root.data);
  	inOrder(root.right);
  }
  ```

- 后序遍历

  二叉树的后序遍历，就是先递归后序遍历左子树，再递归后序遍历右子树，最后输出根结点的值

  ```java
  public void postOrder(TreeNode root){
  	if(root == null){
  		return;
  	}
  	postOrder(root.left);
  	postOrder(root.right);
  	system.out.println(root.data);
  }
  ```



### 4. 红黑树

- **红黑树特点** :
  1. 每个节点非红即黑；
  2. 根节点总是黑色的；
  3. 每个叶子节点都是黑色的空节点（NIL节点）；
  4. 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；
  5. 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。

- **红黑树的应用** ：TreeMap、TreeSet以及JDK1.8的HashMap底层都用到了红黑树。

- **为什么要用红黑树？** 简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。



## 6. 堆

### 1. 描述

​	堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。任意一个节点的值都大于等于（或小于等于）所有子节点的值。最大堆：每个节点都比子树中所有节点大。最小堆：每个节点都比子树中所有节点小。

### 2. 用途

   存在多次获取最大值或者最小值，多次插入或删除数据。

### 3. 操作
   - **插入元素** ：先将元素放至数组末尾，再自底向上堆化，将末尾元素上浮
   - **删除堆顶元素** ：删除堆顶元素，将末尾元素放至堆顶，再自顶向下堆化，将堆顶元素下沉。也可以自底向上堆化，只是会产生“气泡”，浪费存储空间。最好采用自顶向下堆化的方式。



## 7. 哈希表

1. 哈希表在使用层面上可以理解为一种集合结构 
2. 如果只有key，没有伴随数据value，可以使用HashSet结构
3. 如果既有key，又有伴随数据value，可以使用HashMap结构
4. 有无伴随数据，是HashMap和HashSet唯一的区别，底层的实际结构是一回事 
5. 使用哈希表增(put)、删(remove)、改(put)和查(get)的操作，可以认为时间复杂度为 O(1)，但是常数时间比较大 
6. 放入哈希表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小 
7. 放入哈希表的东西，如果不是基础类型，内部按引用传递，内存占用是这个东西内存地址的大小



## 8. 有序表

1. 有序表在使用层面上可以理解为一种集合结构
2. 如果只有key，没有伴随数据value，可以使用TreeSet结构
3. 如果既有key，又有伴随数据value，可以使用TreeMap结构
4. 有无伴随数据，是TreeSet和TreeMap唯一的区别，底层的实际结构是一回事
5. 有序表和哈希表的区别是，有序表把key按照顺序组织起来，而哈希表完全不组织
6. 红黑树、AVL树、size-balance-tree和跳表等都属于有序表结构，只是底层具体实现不同 
7. 放入有序表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小
8. 放入有序表的东西，如果不是基础类型，必须提供比较器，内部按引用传递，内存占用是这个东西内存地址的大小
9. 不管是什么底层具体实现，只要是有序表，都有以下固定的基本功能和固定的时间复杂度



## 9. 单链表

​	**链表（LinkedList）** 虽然是一种线性表，但是并不会按线性的顺序存储数据，使用的不是连续的内存空间来存储数据。

​	链表的插入和删除操作的复杂度为 O(1) ，只需要知道目标位置元素的上一个元素即可。但是，在查找一个节点或者访问特定位置的节点的时候复杂度为 O(n) 。

​	使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间,实现灵活的内存动态管理。但链表不会节省空间，相比于数组会占用更多的空间，因为链表中每个节点存放的还有指向其他节点的指针。除此之外，链表不具有数组随机读取的优点。

单链表和双链表结构只需要给定一个头部节点head，就可以找到剩下的所有的节点。

- 单链表的节点结构

  ```java
  Class Node{ 
      V value; 
      Node next; 
  } 
  ```

​		由以上结构的节点依次连接起来所形成的链叫单链表结构。 

- 双链表的节点结构 

  ```java
  Class Node{ 
  	V value; 
  	Node next; 
  	Node last; 
  }
  ```

  由以上结构的节点依次连接起来所形成的链叫双链表结构。 

  

## 10. 排序

   同样值的个体之间，如果不因为排序而改变相对次序，就是这个排序是有稳定性的；否则就没有。 

   - 不具备稳定性的排序： 选择排序、快速排序、堆排序 
   - 具备稳定性的排序： 冒泡排序、插入排序、归并排序、一切桶排序思想下的排序
   - 目前没有找到时间复杂度O(N*logN)，额外空间复杂度O(1)，又稳定的排序。



## 11. 图

1. 描述

   图就是由顶点的有穷非空集合和顶点之间的边组成的集合。通常表示为：**G(V,E)**，其中，G表示一个图，V表示顶点的集合，E表示边的集合。

2. 概念

   - 顶点

     图中的数据元素，我们称之为顶点，图至少有一个顶点（非空有穷集合）

     对应到好友关系图，每一个用户就代表一个顶点。

   - 边

     顶点之间的关系用边表示。

     对应到好友关系图，两个用户是好友的话，那两者之间就存在一条边。

   - 度

     度表示一个顶点包含多少条边，在有向图中，还分为出度和入度，出度表示从该顶点出去的边的条数，入度表示进入该顶点的边的条数。

     对应到好友关系图，度就代表了某个人的好友数量。

   - 无向图和有向图

     边表示的是顶点之间的关系，有的关系是双向的，比如同学关系，A是B的同学，那么B也肯定是A的同学，那么在表示A和B的关系时，就不用关注方向，用不带箭头的边表示，这样的图就是无向图。

     有的关系是有方向的，比如父子关系，师生关系，微博的关注关系，A是B的爸爸，但B肯定不是A的爸爸，A关注B，B不一定关注A。在这种情况下，我们就用带箭头的边表示二者的关系，这样的图就是有向图。

   - 无权图和带权图

     对于一个关系，如果我们只关心关系的有无，而不关心关系有多强，那么就可以用无权图表示二者的关系。

     对于一个关系，如果我们既关心关系的有无，也关心关系的强度，比如描述地图上两个城市的关系，需要用到距离，那么就用带权图来表示，带权图中的每一条边一个数值表示权值，代表关系的强度。

3. 图的存储

   - 邻接矩阵存储

     邻接矩阵将图用二维矩阵存储，是一种较为直观的表示方式。

     如果第i个顶点和第j个顶点之间有关系，且关系权值为n，则 `A[i][j]=n` 。

     在无向图中，我们只关心关系的有无，所以当顶点i和顶点j有关系时，`A[i][j]`=1，当顶点i和顶点j没有关系时，`A[i][j]`=0。

     **无向图的邻接矩阵是一个对称矩阵**

     邻接矩阵存储的方式优点是简单直接（直接使用一个二维数组即可），并且，在获取两个定点之间的关系的时候也非常高效（直接获取指定位置的数组元素的值即可）。但是，这种存储方式的缺点也比较明显，那就是比较浪费空间，

   - 邻接链表使用一个链表来存储某个顶点的所有后继相邻顶点。对于图中每个顶点Vi，把所有邻接于Vi的顶点Vj链成一个单链表，这个单链表称为顶点Vi的 **邻接表**。

     - 在无向图中，邻接表元素个数等于边的条数的两倍，如左图所示的无向图中，边的条数为7，邻接表存储的元素个数为14。
     - 在有向图中，邻接表元素个数等于边的条数，如右图所示的有向图中，边的条数为8，邻接表存储的元素个数为8。

4. 图的遍历

   - 图的宽度优先遍历

     1. 利用队列实现
     2. 从源节点开始依次按照宽度进队列，然后弹出
     3. 每弹出一个点，把该节点所有没有进过队列的邻接点放入队列
     4. 直到队列变空

   - 广度优先遍历

     1. 利用栈实现
     2. 从源节点开始把节点按照深度放入栈，然后弹出
     3. 每弹出一个点，把该节点下一个没有进过栈的邻接点放入栈
     4. 直到栈变空

   - 拓扑排序

     适用范围：要求有向图，且有入度为0的节点，且没有环
     1. 找到入度为0的节点，保存到只存储入度为0的队列中
     2. 添加到结果排序集
     3. 找到此节点指向的其他节点，如果减掉此指向的入度为0，添加到队列和结果集中，循环此步骤

   - kruskal算法（无向图生成最小生成树）

     1. 遍历每个节点，生成对应只有自己的集合
     2. 将图的所有边根据权重升序排列
     3. 判断每条边的始末节点是否在同一个集合中，如果不在同一个集合中，合并两个集合，直到集合包含所有节点

   - Prime算法

     1. 从任意节点检查，将该节点的所有边选出权重最小的边
     2. 检查该边的to节点是否已检查，如果没检查则将该节点的所有边选出权重最小的边
     3. 重复上述步骤，直到所有节点都检查过
